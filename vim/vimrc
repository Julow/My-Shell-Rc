" Vim config

set encoding=utf8
set ignorecase
set hlsearch
set showmatch

set nocompatible
set noswapfile

set wildmenu

set mouse=a

syntax enable

filetype plugin on
filetype indent on

set backspace=eol,start,indent

set autoread
autocmd BufEnter * :checktime

set t_Co=16

set ttimeoutlen=10

set diffopt+=foldcolumn:0

" Netrw
let g:netrw_banner = 0
let g:netrw_nogx = 1

let g:netrw_gx = "<cWORD>"
let g:netrw_browsex_viewer = "xdg-open"

" Default gx is crazy.
function! Gx(url)
  call system(g:netrw_browsex_viewer . " " . shellescape(a:url) . " &")
endfunction

" https://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! VisualSelection()
  let a_save = @a
  try
    silent! normal! gv"ay
    return @a
  finally
    let @a = a_save
  endtry
endfunction

nnoremap gx :call Gx(expand(g:netrw_gx))<return>
vnoremap gx :<C-u>call Gx(VisualSelection())<return>

" Open netrw
nnoremap <Leader>n :Vex<return>

" Shift+tab = escape
inoremap <S-Tab> <Esc>
vnoremap <S-Tab> <Esc>

" Indent
set smarttab
set shiftwidth=2
set tabstop=2
set autoindent
set smartindent
set expandtab

set wrap

" Formatting
set formatoptions+=roj
set nojoinspaces

" Show number of match when searching
set shortmess-=S

" Fold
" Override ZZ and ZQ bindings
set foldmethod=indent
set foldlevelstart=99
nnoremap Z za
vnoremap Z zf
nnoremap z1 :set foldlevel=1<return>
nnoremap z2 :set foldlevel=2<return>

" C-c to clear highlighted text
" This override default C-c
" A custom event is used to allow extensibility
nnoremap <silent> <C-c> :doautocmd User ClearHighlight<return>
inoremap <silent> <C-c> <Esc><C-c>

function! s:clear_highlight()
  if v:hlsearch
    call feedkeys(":nohlsearch\<return>")
  endif
endfunction
autocmd User ClearHighlight call s:clear_highlight()

" Scroll
set scrolloff=10

" Remap # to search for the current word and to search forward
" Use the selection in visual mode
nnoremap # "vyiwge/\<\V<C-R>v\><return>
vnoremap # "vyge/\V<C-R>v<return>

" Repeat substitution and search
nnoremap <expr> & expand(v:hlsearch) ? 'n&' : '"vyiw:s/\C\<\V<C-R>v\>/'
" Substitution from selection
vnoremap & "vy:s/\C\V<C-R>v/

" dP and dO, diffput and diffget the current line
nnoremap dO V:diffget<return>
nnoremap dP V:diffput<return>

" Use system clipboard
set clipboard=unnamedplus

" Set window title
set t_ts=]2;
set t_fs=\\
autocmd BufEnter * let &titlestring = expand("%:t")
set title

" Ruler showing filename
" Show size of the selection in visual mode
function! S_selection()
  let l:m = mode()
  if l:m == "v" || l:m == "\<C-V>"
    let l:c = getpos(".")
    let l:v = getpos("v")
    let l:lines = abs(l:c[1] - l:v[1]) + 1
    if l:m ==# "v"
      let l:chars = abs((line2byte(l:c[1]) + l:c[2]) - (line2byte(l:v[1]) + l:v[2])) + 1
    elseif l:m ==# "V"
      let l:chars = line2byte(max([l:c[1], l:v[1]]) + 1) - 1 - line2byte(min([l:c[1], l:v[1]])) + 1
    else
      let l:chars = abs(l:c[2] - l:v[2]) + 1
    endif
    return l:lines . "-" . l:chars
  else
    return ""
  endif
endfunction

" Show line endings format if it's not unix
function! S_linef()
  return &fileformat == "unix" ? "" : &fileformat
endfunction

" More discreet indicator for unmodifiable or readonly buffers
function! S_readonly()
  return (!&modifiable || &readonly) ? "RO" : ""
endfunction

" Ruler color depending on the current mode
function! S_update_mode()
  let l:m = mode()
  if l:m == "n"
    let l:l = "S_mode_n"
  elseif l:m == "v" || l:m == "\<C-V>"
    let l:l = "S_mode_v"
  elseif l:m == "i" || l:m == "R"
    let l:l = "S_mode_i"
  elseif l:m == "t"
    let l:l = "S_mode_t"
  else
    let l:l = "S_mode_other"
  endif
  execute "highlight link S_mode_link " . l:l
  if !exists('b:s_filename') " Ensure s_filename is set
    call Update_s_filename()
  endif
  return ""
endfunction

" Do some processing on the current filename
function! Update_s_filename()
  let l:f = bufname("%")

  if l:f =~ "^fugitive://"
    " Fugitive URIs are shortened to "symbolic:path"
    " Useful to know which is which when using Fugitive diffsplit
    let l:obj = fugitive#Object(l:f) " Returns a string "HASH:PATH"
    let [ l:hash; path ] = split(l:obj, ":")
    if l:hash == '0'
      let l:symbolic = "staged"
    else
      let l:symbolic = systemlist("git name-rev --name-only " . l:hash)[0]
    endif
    let l:f = join([ l:symbolic ] + path, ":")
  endif

  if l:f =~ "^/"
    " Convert absolute paths to relative paths
    let l:f = fnamemodify(l:f, ":~:.")
  endif

  call setbufvar("%", "s_filename", (l:f != "") ? l:f : "<no filename>")
endfunction

autocmd BufEnter,BufNew,TerminalOpen * call Update_s_filename()

function! S_terminal_update()
  let buf = bufnr("%")
  let b:s_terminal_status = ""
  let b:s_terminal_time = ""
  if getbufvar(buf, "&buftype", "") == "terminal"
    let job = term_getjob(buf)
    let info = job_info(job)
    if info["status"] == "dead"
      if !exists('b:terminal_end_time')
        let b:terminal_end_time = exists('b:terminal_start_time') ? reltime(b:terminal_start_time) : 0
      endif
      let s = info["exitval"]
      let b:s_terminal_status = (s == 0) ? "" : s
      let b:s_terminal_time = printf("%.0fs", reltimefloat(b:terminal_end_time))
    endif
  endif
  return ""
endfunction

autocmd TerminalOpen * let b:terminal_start_time = reltime()

set statusline=%=%{S_update_mode()}%#S_mode_link#%{b:s_filename}%*%< " Mode and file name
set statusline+=\ %(%h\ %)%(%q\ %)%(%w\ %) " Vim's flags
set statusline+=%l:%c%(\ (%{S_selection()})%) " Cursor position and selection
set statusline+=%#S_linef#%(\ %{S_linef()}%) " Line feed format
set statusline+=%#S_readonly#%(\ %{S_readonly()}%) " Readonly flag
set ruler " The ruler is the status line when there is only one window
let &rulerformat = "%50(%)" . &statusline
set rulerformat+=%#S_workspace#%(\ %{$WORKSPACE}%)%#S_fugitive#%(\ %{FugitiveHead(8)}%) " Current Git branch
set statusline^=%#S_terminal_time#%(\ Terminated\ after\ %{b:s_terminal_time}%) " Terminal running time
set statusline^=--%{S_terminal_update()}%#S_terminal_fail#%(\ [exit\ %{b:s_terminal_status}]%) " Terminal exit status
set laststatus=1
set noshowmode

" Per project vimrc
set exrc
set nomodeline " Disable modeline
set secure

" Color adjustments
hi Folded ctermbg=none ctermfg=blue

hi DiffAdd ctermbg=lightgrey ctermfg=none
hi DiffDelete ctermbg=lightgrey ctermfg=red
hi DiffChange ctermbg=none ctermfg=none
hi DiffText ctermbg=lightgrey ctermfg=none

hi VertSplit ctermbg=none ctermfg=lightgrey cterm=none
hi StatusLine ctermbg=none ctermfg=black cterm=nocombine
" nocombine is dummy to avoid Vim printing '^^^'
hi StatusLineNC ctermbg=none ctermfg=black cterm=none
hi StatusLineTerm ctermbg=none ctermfg=none cterm=none
hi StatusLineTermNC ctermbg=none ctermfg=none cterm=none
hi S_readonly ctermbg=none ctermfg=yellow cterm=none
hi S_linef ctermbg=none ctermfg=red cterm=none
hi S_mode_n ctermbg=none ctermfg=none cterm=none
hi S_mode_i ctermbg=none ctermfg=yellow cterm=none
hi S_mode_v ctermbg=none ctermfg=green cterm=none
hi S_mode_t ctermbg=blue ctermfg=none cterm=none
hi S_mode_other ctermbg=none ctermfg=red cterm=none
hi S_fugitive ctermbg=none ctermfg=magenta cterm=none
hi S_workspace ctermbg=none ctermfg=green cterm=none
hi S_terminal_fail ctermbg=none ctermfg=red cterm=none
hi S_terminal_time ctermbg=none ctermfg=yellow cterm=none

" :Gdiffb
" Opens vim-fugitive split diff with the merge-base
command -nargs=1 -complete=custom,fugitive#CompleteObject Gdiffb execute ':Gdiffsplit ' . system("git merge-base " . <q-args> . " HEAD")

" \g to open fugitive status
nnoremap <Leader>g :tab Git<return>

" Ctrl+k and Ctrl+j to move up and down inside wrapped lines
nnoremap <C-j> gj
nnoremap <C-k> gk

" Ctrl+hjkl to Ctrl+w hjkl
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Don't move the cursor to first column when scrolling
set nostartofline

" Syntax for some extensions
autocmd BufNewFile,BufRead *.xkb set ft=xkb

" Q to save file
nnoremap Q :w<return>

" Enable matchit
packadd! matchit

" Delete to the end of the line or to the end of the current matchit pair
function! End_of_line_or_pair()
  let l:initial = getpos('.')
  " Go left, in case we are on the beginning of a pair
  normal h]%
  let l:endofpair = getpos('.')
  call setpos('.', l:initial) " Restore cursor position
  " endofpair is on the same line but isn't under the cursor
  if l:initial[1] == l:endofpair[1] && l:initial[2] < l:endofpair[2]
    normal v]%h
  else
    normal vg_
  endif
endfunction

" Text object for End_of_line_or_pair
noremap <silent> yup :<C-U>call End_of_line_or_pair()<return>

nmap D dyup
nmap C cyup
nmap Y yyup

" Mapping for vim-surround with operator up
nmap g( ysyup(
nmap g) ysyup)
nmap g{ ysyup{
nmap g} ysyup}
nmap g[ ysyup[
nmap g] ysyup]

" Delete text without yanking
nnoremap <Leader>d "_d
vnoremap <Leader>d "_d

" ---

" Require plugin https://github.com/mkotha/conflict3
" [C and ]C to navigate between conflict and enable conflict3 highlighting
" <Leader>C to try to automatically resolve
" <Leader>K to resolve the conflict by taking the version the cursor is in

" Search a conflict and highlight it with conflict3
" Flag can be 'b' to search backward
function! Next_conflict(flag)
  let next = search('\V\^<<<<<<<', a:flag)
  if next == 0
    echohl ErrorMsg
    echomsg "No conflict found"
    echohl None
    return
  endif
  call setpos('.', next)
  echomsg "Found"
  Conflict3Highlight
endfunction

nnoremap [C :call Next_conflict('b')<return>
nnoremap ]C :call Next_conflict('')<return>
nnoremap <Leader>C :Conflict3ResolveAll \| Conflict3Shrink!<return>
nnoremap <Leader>K :Conflict3TakeThis<return>

" Clear conflict3 highlight on C-c
autocmd User ClearHighlight Conflict3Clear

" Run &formatprg (like the default), handle non-zero exit code and stderr
" "%" is expanded to the current file name, shell escaped
function! Run_formatter()
  if &formatprg == ""
    return 1 " No formatprg, fallback to default
  endif
  if v:char != ""
    return 1 " Automatic formatting, fallback to default
  endif
  " Expand %
  let cmd = substitute(&formatprg, "%", expand("%::S"), "")
  let lines = getline(v:lnum, v:lnum + v:count - 1)
  let tempfile = tempname()
  let errors = systemlist(cmd . " > " . tempfile, lines)
  if v:shell_error == 0
    execute v:lnum "delete _" v:count
    let read_at = max([v:lnum - 1, 0])
    execute read_at "read" tempfile
  else
    echohl ErrorMsg
    echon "Error while executing '" cmd "' (" v:shell_error "):\n" join(errors, "\n")
    echohl None
  endif
  call delete(tempfile)
  return 0
endfunction

set formatexpr=Run_formatter()

" Format a paragraph
nnoremap gQ gqip

" Map C-= to reindent the current line
" Also in insert mode
inoremap <C-=> <C-o>==
nnoremap <C-=> ==

" Bind \[ and \] to navigate between quickfixes
nnoremap <Leader>[ :cprevious<return>
nnoremap <Leader>] :cnext<return>

function! Quickfix_open_split()
  let l:n = line(".")
  execute "new"
  execute l:n "cc"
endfunction

" Open the quickfix window when it changes and is not empty
autocmd QuickFixCmdPost * cwindow

" Bind C-Enter to open a quickfix entry in a new split
" Bind C-w Enter for new tabs
autocmd FileType qf nnoremap <buffer> <C-Enter> :call Quickfix_open_split()<return>

" Use 'git grep' as :grep
set grepprg=git\ grep\ --recurse-submodules\ -n

nnoremap <Leader>m :make!<return>

" Close the quickfix window
nnoremap <Leader>M :cclose<return>

" wincmd
nmap <Space> <C-w>

" Open a new tab page
nmap <Leader>T :tab new<return>

let g:runtest_buf = -1

" Runtest key
" Example: let g:runtestprg = "make test"
function! Runtest()
  if !exists("g:runtestprg")
    echohl WarningMsg
    echon "g:runtestprg is not set"
    echohl None
    return
  endif
  let options = {}
  let previous_buf = bufnr(g:runtest_buf)
  if previous_buf > 0 " Reuse previous terminal window if any
    let job = term_getjob(previous_buf)
    let info = job_info(job)
    if info["status"] == "run" " Kill the previous job if running
      if job_stop(job) != 1
        echo "Couldn't kill current job"
        return
      endif
      call term_wait(previous_buf)
    endif
    let win = bufwinnr(previous_buf)
    execute win "wincmd w"
    let options['curwin'] = 1
  endif
  let cmd = expandcmd(g:runtestprg)
  let g:runtest_buf = term_start(cmd, options)
endfunction

nnoremap <Leader>r :call Runtest()<return>

" Find a file by name with fd
function! Fd(...)
  let args = map(copy(a:000), 'shellescape(v:val)')
  let lines = systemlist('fd ' . join(args))
  if len(lines) == 0
    echohl WarningMsg
    echo "No match found"
    echohl None
  else
    call setqflist([], 'r', {'lines': lines, 'efm': '%f'})
    cwindow
  endif
endfunction

command -nargs=* Fd call Fd(<f-args>)

" gf open file that don't exist
nnoremap gf :e <cfile><return>
" gF to open a file in a new window
nnoremap gF :split <cfile><return>
" open a file in a new tab
nnoremap <C-w>gf :tab new <cfile><return>

" Originally from kristijanhusak, https://github.com/tpope/vim-fugitive/issues/132#issuecomment-649516204
" With some improvements
command! -nargs=* DiffHistory call s:view_git_history(<f-args>)

function! s:view_git_history(...) abort
  let args = map(copy(a:000), 'shellescape(v:val)')
  execute "Git difftool --name-only " . join(args)
  call s:diff_current_quickfix_entry()
  " Bind <CR> for current quickfix window to properly set up diff split layout after selecting an item
  " There's probably a better way to map this without changing the window
  copen
  nnoremap <buffer> <CR> <CR><BAR>:call <sid>diff_current_quickfix_entry()<CR>
  wincmd p
endfunction

function s:diff_current_quickfix_entry() abort
  " Cleanup windows
  for window in getwininfo()
    if window.winnr !=? winnr() && bufname(window.bufnr) =~? '^fugitive:'
      exe 'bdelete' window.bufnr
    endif
  endfor
  cc
  call s:add_mappings()
  let qf = getqflist({'context': 0, 'idx': 0})
  if get(qf, 'idx') && type(get(qf, 'context')) == type({}) && type(get(qf.context, 'items')) == type([])
    let diff = get(qf.context.items[qf.idx - 1], 'diff', [])
    echom string(reverse(range(len(diff))))
    for i in reverse(range(len(diff)))
      " Silent to avoid error on removed files
      silent exe (i ? 'leftabove' : 'rightbelow') 'vert diffsplit' fnameescape(diff[i].filename)
      call s:add_mappings()
    endfor
  endif
endfunction

function! s:add_mappings() abort
  nnoremap <leader>] :cnext <BAR> :call <sid>diff_current_quickfix_entry()<CR>
  nnoremap <leader>[ :cprevious <BAR> :call <sid>diff_current_quickfix_entry()<CR>
  " Reset quickfix height. Sometimes it messes up after selecting another item
  11copen
  wincmd p
endfunction

" Shortcut for open running a program in the terminal
nnoremap ! :term<space>
nnoremap <C-1> :tab term<space>
tnoremap <C-w>! <C-w>:term<space>

" Restart a terminal job
function! Restart_terminal_job(...)
  let buf = bufnr("%")
  let job = term_getjob(buf)
  let info = job_info(job)
  if info["status"] == "run"
    if job_stop(job) != 1
      echo "Couldn't kill current job"
      return
    endif
    call term_wait(buf)
  endif
  let cmd = (len(a:000) > 0) ? copy(a:000) : info["cmd"]
  call term_start(cmd, #{ curwin: 1 })
endfunction

function! Last_job_command()
  let info = job_info(term_getjob(bufnr("%")))
  return join(info["cmd"], " ")
endfunction

" Terminal normal mapping
function! Setup_terminal_map()

  " Restart a job in the current terminal
  " If no arguments are given, restart the previous command
  command! -nargs=* -complete=file RestartJob call Restart_terminal_job(<f-args>)

  " Restart a job in a terminal
  nnoremap <buffer> <C-return> :RestartJob<return>

  " Type RestartJob command and allow to edit it
  nnoremap <buffer> <C-1> :RestartJob <C-r>=Last_job_command()<return>

endfunction

autocmd TerminalOpen * call Setup_terminal_map()
